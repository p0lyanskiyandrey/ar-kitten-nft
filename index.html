<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AR –ö–æ—Ç–µ–Ω–æ–∫ - –¢–æ—á–∫–∞ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
            background: black;
        }
        
        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }
        
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            z-index: 4;
            cursor: pointer;
            border: 3px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            animation: pulse-crosshair 2s infinite;
            transition: all 0.3s ease;
        }
        
        #crosshair:hover {
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.8);
        }
        
        #crosshair:active {
            transform: translate(-50%, -50%) scale(0.9);
        }
        
        @keyframes pulse-crosshair {
            0% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
            100% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
        }
        
        .crosshair-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid white;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
        }
        
        .crosshair-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }
        
        #movement-area {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }
        
        #instruction {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            text-align: center;
            backdrop-filter: blur(10px);
            z-index: 5;
            animation: fade-in-out 4s infinite;
        }
        
        @keyframes fade-in-out {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        .placed-indicator {
            position: fixed;
            width: 100px;
            height: 100px;
            border: 3px solid #00FF88;
            border-radius: 50%;
            background: rgba(0, 255, 136, 0.2);
            animation: place-effect 1s ease-out;
            pointer-events: none;
            z-index: 6;
        }
        
        @keyframes place-effect {
            0% { 
                transform: translate(-50%, -50%) scale(0);
                opacity: 1;
            }
            100% { 
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <video id="video" autoplay playsinline muted></video>
    <div id="movement-area"></div>
    
    <div id="crosshair">
        <div class="crosshair-inner">
            <div class="crosshair-dot"></div>
        </div>
    </div>
    
    <div id="instruction">
        üéØ –ù–∞–∂–º–∏—Ç–µ –Ω–∞ —Ç–æ—á–∫—É —á—Ç–æ–±—ã —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å –∫–æ—Ç–µ–Ω–∫–∞
    </div>

    <script>
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let video, scene, camera, renderer;
        let kittens = [];
        
        // –ü–æ–∑–∏—Ü–∏—è –∫–∞–º–µ—Ä—ã (–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è)
        let cameraPosition = {
            x: 0,
            y: 1.6, // –í—ã—Å–æ—Ç–∞ —á–µ–ª–æ–≤–µ—á–µ—Å–∫–∏—Ö –≥–ª–∞–∑
            z: 0
        };
        
        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞—Å–∞–Ω–∏—è–º–∏ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã
        let touches = {
            startX: 0,
            startY: 0,
            lastX: 0,
            lastY: 0,
            isMoving: false,
            startDistance: 0
        };
        
        let isFirstKitten = true;
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        async function init() {
            try {
                // –ó–∞–ø—É—Å–∫ –∫–∞–º–µ—Ä—ã
                video = document.getElementById('video');
                await startCamera();
                
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è 3D
                init3D();
                
                // –°–æ–±—ã—Ç–∏—è
                setupEvents();
                
                // –ó–∞–ø—É—Å–∫ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞
                animate();
                
                console.log('AR —Å —Ç–æ—á–∫–æ–π —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –≥–æ—Ç–æ–≤');
                
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏:', error);
                showError(error.message);
            }
        }
        
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: false
                });
                
                video.srcObject = stream;
                
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });
                
            } catch (error) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: true,
                        audio: false
                    });
                    
                    video.srcObject = stream;
                    
                    return new Promise((resolve) => {
                        video.onloadedmetadata = () => {
                            video.play();
                            resolve();
                        };
                    });
                    
                } catch (fallbackError) {
                    throw new Error('–ö–∞–º–µ—Ä–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞');
                }
            }
        }
        
        function init3D() {
            // –°—Ü–µ–Ω–∞
            scene = new THREE.Scene();
            
            // –ö–∞–º–µ—Ä–∞
            camera = new THREE.PerspectiveCamera(
                75, // –®–∏—Ä–æ–∫–∏–π —É–≥–æ–ª –æ–±–∑–æ—Ä–∞
                window.innerWidth / window.innerHeight,
                0.01,
                100
            );
            
            updateCameraPosition();
            
            // –†–µ–Ω–¥–µ—Ä–µ—Ä
            renderer = new THREE.WebGLRenderer({ 
                alpha: true,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = '0';
            renderer.domElement.style.left = '0';
            renderer.domElement.style.zIndex = '2';
            renderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(renderer.domElement);
            
            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            setupLighting();
        }
        
        function setupLighting() {
            // –Ø—Ä–∫–æ–µ –æ–∫—Ä—É–∂–∞—é—â–µ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π —Å–≤–µ—Ç
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(3, 5, 3);
            scene.add(directionalLight);
            
            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ
            const pointLight1 = new THREE.PointLight(0xffffff, 0.5, 20);
            pointLight1.position.set(-3, 3, 3);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0xffffff, 0.5, 20);
            pointLight2.position.set(3, 3, -3);
            scene.add(pointLight2);
        }
        
        function setupEvents() {
            const crosshair = document.getElementById('crosshair');
            const movementArea = document.getElementById('movement-area');
            const instruction = document.getElementById('instruction');
            
            // –ö–ª–∏–∫ –ø–æ —Ç–æ—á–∫–µ - —Å–æ–∑–¥–∞–Ω–∏–µ –∫–æ—Ç–µ–Ω–∫–∞
            crosshair.addEventListener('click', function(event) {
                event.stopPropagation();
                placeKittenAtCrosshair();
            });
            
            crosshair.addEventListener('touchstart', function(event) {
                event.preventDefault();
                event.stopPropagation();
                placeKittenAtCrosshair();
            }, { passive: false });
            
            // –î–≤–∏–∂–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã
            let isDragging = false;
            
            movementArea.addEventListener('touchstart', function(event) {
                if (event.touches.length === 1) {
                    touches.startX = event.touches[0].clientX;
                    touches.startY = event.touches[0].clientY;
                    touches.lastX = touches.startX;
                    touches.lastY = touches.startY;
                    isDragging = true;
                } else if (event.touches.length === 2) {
                    const dx = event.touches[0].clientX - event.touches[1].clientX;
                    const dy = event.touches[0].clientY - event.touches[1].clientY;
                    touches.startDistance = Math.sqrt(dx * dx + dy * dy);
                }
                
                // –°–∫—Ä—ã–≤–∞–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –ø–æ—Å–ª–µ –ø–µ—Ä–≤–æ–≥–æ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
                if (instruction) {
                    instruction.style.display = 'none';
                }
            });
            
            movementArea.addEventListener('touchmove', function(event) {
                if (event.touches.length === 1 && isDragging) {
                    const deltaX = event.touches[0].clientX - touches.lastX;
                    const deltaY = event.touches[0].clientY - touches.lastY;
                    
                    // –ü–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã (–æ—Å–º–æ—Ç—Ä –≤–æ–∫—Ä—É–≥)
                    const sensitivity = 0.005;
                    
                    // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç
                    const angleY = deltaX * sensitivity;
                    const cosY = Math.cos(angleY);
                    const sinY = Math.sin(angleY);
                    
                    const newX = cameraPosition.x * cosY - cameraPosition.z * sinY;
                    const newZ = cameraPosition.x * sinY + cameraPosition.z * cosY;
                    
                    cameraPosition.x = newX;
                    cameraPosition.z = newZ;
                    
                    // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç
                    cameraPosition.y += deltaY * sensitivity;
                    cameraPosition.y = Math.max(0.2, Math.min(3, cameraPosition.y));
                    
                    updateCameraPosition();
                    
                    touches.lastX = event.touches[0].clientX;
                    touches.lastY = event.touches[0].clientY;
                    
                } else if (event.touches.length === 2) {
                    // –ó—É–º (–¥–≤–∏–∂–µ–Ω–∏–µ –≤–ø–µ—Ä–µ–¥/–Ω–∞–∑–∞–¥)
                    const dx = event.touches[0].clientX - event.touches[1].clientX;
                    const dy = event.touches[0].clientY - event.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (touches.startDistance > 0) {
                        const zoomFactor = distance / touches.startDistance;
                        const moveAmount = (zoomFactor - 1) * 2;
                        
                        // –î–≤–∏–≥–∞–µ–º—Å—è –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –≤–∑–≥–ª—è–¥–∞
                        const forward = new THREE.Vector3(0, 0, -1);
                        forward.applyQuaternion(camera.quaternion);
                        
                        cameraPosition.x += forward.x * moveAmount;
                        cameraPosition.z += forward.z * moveAmount;
                        
                        updateCameraPosition();
                    }
                    
                    touches.startDistance = distance;
                }
                
                event.preventDefault();
            }, { passive: false });
            
            movementArea.addEventListener('touchend', function() {
                isDragging = false;
                touches.startDistance = 0;
            });
        }
        
        function placeKittenAtCrosshair() {
            // –í—ã—á–∏—Å–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –≤ –º–∏—Ä–µ –≥–¥–µ —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å –∫–æ—Ç–µ–Ω–∫–∞
            // –†–∞–∑–º–µ—â–∞–µ–º –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ 2 –º–µ—Ç—Ä–∞ –ø–µ—Ä–µ–¥ –∫–∞–º–µ—Ä–æ–π
            const direction = new THREE.Vector3(0, 0, -2);
            direction.applyQuaternion(camera.quaternion);
            
            const kittenPosition = {
                x: cameraPosition.x + direction.x,
                y: cameraPosition.y + direction.y, 
                z: cameraPosition.z + direction.z
            };
            
            createKittenAt(kittenPosition);
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç —Ä–∞–∑–º–µ—â–µ–Ω–∏—è
            showPlaceEffect();
            
            if (isFirstKitten) {
                updateInstruction('–î–≤–∏–≥–∞–π—Ç–µ—Å—å —á—Ç–æ–±—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å –∫–æ—Ç–µ–Ω–∫–∞!');
                isFirstKitten = false;
            }
        }
        
        function createKittenAt(position) {
            // –°–æ–∑–¥–∞–µ–º –≥—Ä—É–ø–ø—É –¥–ª—è –∫–æ—Ç–µ–Ω–∫–∞
            const kittenGroup = new THREE.Group();
            kittenGroup.position.set(position.x, position.y, position.z);
            
            console.log(`–ö–æ—Ç–µ–Ω–æ–∫ —Ä–∞–∑–º–µ—â–µ–Ω –≤ –ø–æ–∑–∏—Ü–∏–∏: ${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)}`);
            
            // –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä—ã
            const loader = new THREE.TextureLoader();
            loader.load('kitten.jpg', 
                function(texture) {
                    console.log('‚úÖ –ö–æ—Ç–µ–Ω–æ–∫ —Å —Ç–µ–∫—Å—Ç—É—Ä–æ–π —Å–æ–∑–¥–∞–Ω!');
                    createKittenMesh(kittenGroup, texture);
                },
                undefined,
                function(error) {
                    console.log('–°–æ–∑–¥–∞–µ–º –∫–æ—Ç–µ–Ω–∫–∞ –±–µ–∑ —Ç–µ–∫—Å—Ç—É—Ä—ã');
                    createKittenMesh(kittenGroup, null);
                }
            );
            
            scene.add(kittenGroup);
            kittens.push(kittenGroup);
        }
        
        function createKittenMesh(group, texture) {
            // –ë–æ–ª—å—à–æ–π —Ä–∞–∑–º–µ—Ä –∫–∞—Ä—Ç–∏–Ω—ã (1x1 –º–µ—Ç—Ä)
            const geometry = new THREE.PlaneGeometry(1, 1);
            
            let material;
            if (texture) {
                material = new THREE.MeshLambertMaterial({ 
                    map: texture,
                    transparent: false,
                    side: THREE.DoubleSide
                });
            } else {
                // Fallback —Ü–≤–µ—Ç
                material = new THREE.MeshLambertMaterial({ 
                    color: 0x9B59B6,
                    transparent: false
                });
            }
            
            const kittenMesh = new THREE.Mesh(geometry, material);
            group.add(kittenMesh);
            
            // –ö—Ä–∞—Å–∏–≤–∞—è —Ä–∞–º–∫–∞
            const frameGeometry = new THREE.RingGeometry(0.52, 0.56, 32);
            const frameMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFD700, // –ó–æ–ª–æ—Ç–∞—è —Ä–∞–º–∫–∞
                transparent: false
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.z = -0.01;
            group.add(frame);
            
            // –ú–∞–≥–∏—á–µ—Å–∫–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ
            const glowGeometry = new THREE.RingGeometry(0.57, 0.62, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x9B59B6,
                transparent: true,
                opacity: 0.4
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.z = -0.02;
            group.add(glow);
            
            // –ö–æ—Ç–µ–Ω–æ–∫ –≤—Å–µ–≥–¥–∞ –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç—Å—è –∫ –∫–∞–º–µ—Ä–µ
            group.userData.faceCamera = true;
            group.userData.glowAnimation = 0;
        }
        
        function showPlaceEffect() {
            const effect = document.createElement('div');
            effect.className = 'placed-indicator';
            effect.style.left = '50%';
            effect.style.top = '50%';
            document.body.appendChild(effect);
            
            setTimeout(() => {
                if (document.body.contains(effect)) {
                    document.body.removeChild(effect);
                }
            }, 1000);
        }
        
        function updateInstruction(text) {
            const instruction = document.getElementById('instruction');
            if (instruction) {
                instruction.textContent = text;
                instruction.style.display = 'block';
                
                setTimeout(() => {
                    if (instruction) {
                        instruction.style.display = 'none';
                    }
                }, 3000);
            }
        }
        
        function updateCameraPosition() {
            camera.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);
            
            // –ö–∞–º–µ—Ä–∞ —Å–º–æ—Ç—Ä–∏—Ç –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –ø–µ—Ä–≤–æ–≥–æ –∫–æ—Ç–µ–Ω–∫–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)
            if (kittens.length > 0) {
                camera.lookAt(kittens[0].position);
            } else {
                // –ò–Ω–∞—á–µ —Å–º–æ—Ç—Ä–∏–º –≤–ø–µ—Ä–µ–¥
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(camera.quaternion);
                camera.lookAt(
                    cameraPosition.x + forward.x,
                    cameraPosition.y + forward.y,
                    cameraPosition.z + forward.z
                );
            }
        }
        
        function showError(message) {
            document.body.innerHTML = `
                <div style="
                    color: white; 
                    padding: 20px; 
                    text-align: center; 
                    font-family: Arial; 
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    height: 100vh;
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                ">
                    <div style="font-size: 48px; margin-bottom: 20px;">üì±</div>
                    <h2>–ù—É–∂–µ–Ω –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ</h2>
                    <p style="max-width: 300px; line-height: 1.5;">
                        –†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ –¥–ª—è AR
                    </p>
                    <button onclick="location.reload()" style="
                        padding: 15px 30px; 
                        font-size: 16px; 
                        background: #9B59B6; 
                        color: white; 
                        border: none; 
                        border-radius: 10px; 
                        margin-top: 20px;
                        cursor: pointer;
                    ">
                        üîÑ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞
                    </button>
                </div>
            `;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // –ê–Ω–∏–º–∞—Ü–∏—è –∫–æ—Ç—è—Ç
            kittens.forEach(kitten => {
                // –ö–æ—Ç–µ–Ω–æ–∫ –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç—Å—è –∫ –∫–∞–º–µ—Ä–µ
                if (kitten.userData.faceCamera) {
                    kitten.lookAt(camera.position);
                }
                
                // –ê–Ω–∏–º–∞—Ü–∏—è —Å–≤–µ—á–µ–Ω–∏—è
                if (kitten.userData.glowAnimation !== undefined) {
                    kitten.userData.glowAnimation += 0.02;
                    const glowChild = kitten.children[2]; // glow element
                    if (glowChild) {
                        glowChild.material.opacity = 0.2 + Math.sin(kitten.userData.glowAnimation) * 0.2;
                    }
                }
            });
            
            renderer.render(scene, camera);
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ—Å–∞–π–∑–∞
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // –ó–∞–ø—É—Å–∫
        window.addEventListener('load', init);
        
        console.log('üéØ AR —Å —Ç–æ—á–∫–æ–π —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω');
    </script>
</body>
</html>
